# 块级作用域绑定

块级作用域绑定的let和const是es6引入的词法作用域。这两个关键字的引入让js声明变量的语法与其他语言相似，降低了产生错误的几率，因为变量只会在需要他们的地方声明。

#### var声明和变量提升

var给我们最大的困扰是**变量提升**。使用var关键字声明变量，无论我们声明位置在哪里，都会提升到当前作用域的最顶部，就是我们常说的**变量提升**机制

```
function a() {
  console.log(b); //undefined 表明变量已经提升，但是没有赋值
  var b = 1
};
```

上面的代码相当于：

```
function a(){
    var b
    console.log(b); //声明b会提升到函数作用域顶部，初始化操作留在了原初进行。
    b = 1
};
```

变量提升有时会导致程序中出现bug。为此，es6引入块级作用域来强化对变量生命周期的控制。

#### 块级声明

块级作用域用于在指定块的作用域之外无法访问的变量。

##### let

let声明的用法与var一致。用let替代var来声明变量，就可以把变量的作用域限制在当前的块中。let声明不会被提升，因此我们将let声明放在块作用域的顶部，以便整个代码块都可以访问。

```
function a() {
  if (true) {
    let a = 1;
    console.log(a); //1
  }
}
```

在同一个作用域中不能用let重复定义已经存在的标识符。

```
var a = 1;
let a = 2;  //报错
```

##### const

const声明表示常量，其值一旦声明后无法修改，因此通过const声明的常量必须进行初始化，不可以留到以后赋值。

```
const a; //报错 常量为初始化
```

const和let关键字有很多相似之处：1.都是块级标识符，只在声明所在的块级作用域内有效；2.没有**变量提升**；3.不能重复声明。
既然没有变量提升，也就和let一样有暂时性死区，所以也只能**先声明，在访问**

const和let有一处很大的不同，即都不可以为const定义的常量再赋值。

```
const a = 1;
a = 2; //报错。 因为const声明的变量无法重新赋值。
```

const声明对象不允许修改绑定，但是可以修改绑定对象的属性值。

```
const obj = {
  name:'xm'
}
obj.name = 'hh'
obj = {
  name:'tt' //报错
}
```

切记，const声明不允许修改绑定，但允许修改绑定的值

#### 临时死区

count和let关键字声明变量不会被提升到作用域顶部，如果在声明之前访问这些变量，就会报错，就是临时死区

```
function a(){
    if(true){
        console.log(a); //临时死区,用来描述变量不提升的现象
        console.log(b); //undefined
        const a = 1;
        var b = 2;
    }
    console.log(a); //undefined  let关键字只在块中有效，所以在if块之外访问a是无效的
    console.log(b); //2  
}
```

因此，用let和const关键字的正确使用方法是：先声明，在访问。

#### 块级绑定最佳实践

let关键字实际上与我们想要的var一样，只要可以使用var的情况下我们都可以使用let关键字进行替代。
对于需要写保护的变量，我们就会使用const关键字。

而更加流行的一种用法是：我们默认使用const，只有需要改变的变量的值时使用let。因为大部分变量初始化后不应该再改变，很多预料之外的bug是由变量值的改变引起的。

#### 总结

1.我们应该会使用let和const关键字的定义。
2.我们需要注意let和const关键字产生临时死区的问题。
3.最后我们应该再项目中使用这两个es6添加的关键字。


