# 块级作用域绑定

如果写过其他编程语言的开发者对块级作用域肯定不陌生，但在JavaScript中是没有块级作用域的，我们通常需要其他方法间接的实现块级的作用。

**块级作用域**用于在指定块的作用域之外无法访问的变量。

直到ES6才加入了块级作用域，**let**和**const**关键字的加入让JavaScript声明变量的语法与其他语言相似.

### var

**let**和**const**关键字的加入之前我们使用的是var关键字声明变量。

var给我们最大的困扰是**变量提升**。使用var关键字声明变量，无论我们声明位置在哪里，都会提升到当前作用域的最顶部。

```
function a() {
  console.log(b); //undefined 表明变量已经提升，但是没有赋值
  var b = 1
};
```

上面的代码会将变量提升到作用域顶部。

```
function a(){
    var b
    console.log(b); //声明b会提升到函数作用域顶部，初始化操作留在了原初进行。
    b = 1
};
```

所以说**变量提升**机制是我们平时最应该注意的地方。它会导致程序中出现bug。为此，ES6引入块级作用域来强化对变量生命周期的控制。

### let

let关键字的用法与var一致。用let替代var来声明变量，就可以把变量的作用域限制在当前的块中。
let声明变量不会被提升，因此我们将let声明放在块作用域的顶部，以便整个代码块都可以访问。

```
function a() {
  if (true) {
    let a = 1;
    console.log(a); //1
  }
}
```

在同一个作用域中不能用let重复定义已经存在的标识符。

```
var a = 1;
let a = 2;  //报错
```

### const

const关键字表示声明**常量**，其值一旦声明后无法修改，因此通过const声明的常量必须进行初始化，不可以留到以后赋值。

```
const a; //报错 常量为初始化
```

### const和let的相似处

const和let关键字有很多相似之处：

* 都是块级标识符，只在声明所在的块级作用域内有效；
* 没有**变量提升**；
* 不能重复声明。

既然没有变量提升，const和let都有暂时性死区（下面会说到），只能**先声明，在访问**

### const和let的差异处

const和let有一处很大的不同，即const定义的常量不可以再赋值。

```
const a = 1;
a = 2; //报错。 因为const声明的变量无法重新赋值。
```

虽然const声明对象不允许修改绑定，但是可以修改绑定对象的属性值。

```
const obj = {
  name:'xm'
}
obj.name = 'hh'
obj = {
  name:'tt' //报错
}
```

切记，const声明不允许修改绑定，但允许修改绑定的值。而let则可以再赋值


### 临时死区

count和let关键字声明变量不会被提升到作用域顶部，如果在声明之前访问这些变量，就会报错，就是临时死区

```
function a(){
    if(true){
        console.log(a); //临时死区,用来描述变量不提升的现象
        console.log(b); //undefined
        const a = 1;
        var b = 2;
    }
    console.log(a); //undefined  let关键字只在块中有效，所以在if块之外访问a是无效的
    console.log(b); //2  
}
```

因此，用let和const关键字的正确使用方法是上面说到的：**先声明，在访问**。

### 最佳实践

let关键字实际上与我们想要的var一样，只要可以使用var的情况下我们都可以使用let关键字进行替代。
对于需要写保护的变量，我们就会使用const关键字。

而更加流行的一种用法是：我们默认使用const，只有需要改变的变量的值时使用let。因为大部分变量初始化后不应该再改变，很多预料之外的bug是由变量值的改变引起的。

### 总结

看完这章，我们应该掌握的点：

1.我们应该会使用并知道在何时使用var、let和const关键字。
2.我们需要注意let和const关键字产生临时死区的问题。



