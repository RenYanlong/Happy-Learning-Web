# CSS的层叠和继承

在实际工作中，我们会在一个元素上匹配多个选择器，那浏览器会根据哪个选择器中的规则去渲染样式？这样我们就引出了层叠，而层叠就是控制元素属性如何从不同的规则中脱颖而出成为我们看得到样式。

## 层叠

在官方的文档中给了我们三个让人**看上去**很让人困惑的因素：重要性、专用性、源代码次序。如果我们用大白话解释的化就是：一看inportant、二看权重、三看书写顺序。

下面我们就分别说说这三个因素。

### 重要性（important）

！important，这个特别的用法总是优先与其他规则（不全是，在遇见像是max-hight，important可能会出现没有作用的时候）。

我们看个例子：

```html
// HTML

<div id='setColor'>this is div2</div>
<div id='setColor' class='setColorImp'>this id div2</div>
```
```CSS
// CSS

#setColor {
  color: red;
}
.setColorImp {
  color: green !important;
}
```

最终第二个div元素会显示什么颜色呢？

是green。理论上在ID选择器上的属性优先级大于类选择器上相同的属性，应该显示的是红色。但是一开始说到了important总是优先于其他规则，所以第二个dib元素显示的为green。

！important实际上改变了正常的层叠的工作方式。在实际使用中除非无法用覆盖的方式无法解决，而使用！important。只要能覆盖样式解决，就不要使用！important。

### 专用性（权重）

权重是衡量选择器的具体程度的一种方法，一个选择器具有的权重的量是用四种不同的值来衡量的，它们可以被认为是千位，百位，十位和个位。
一一对应的是，在style属性中、ID选择器、类选择器、简单选择器。

举几个例子会更加的清楚：

```
p{
  // 简单选择器的权重为1
}
.class{
  // 类选择器的权重为10
}
#ID{
  //ID选择器的权重为100
}
<div style='color'></div> //行内样式的权重为1000
```

如果我们使用的是组合器，则将每个选择器的权重相加就可以得出整个的权重，如果多个选择器同时作用在一个元素上，就根据选择器或者组合器的权重去选择。

这里不会举复杂的选择器，我们就举一个简单的

```
<p class='col'>测试选择器的权重</p>

.col{
  color:red;
}
p{
  color:green;
}

```

这个例子最后展示出的颜色为red，因为.col的权重为10，p的权重为1，.col的权重大于p的权重，所以会以.col的样式展现出来。

当然更复杂的选择器，我们按照规律将其一一相加，就可以得出权重。这也就是我们互相竞争比较的第二个条件。

### 源代码次序（书写顺序）

如果多个相互竞争的选择器具有相同的重要性和专用性，那么第三个因素将帮助决定哪一个规则获胜——后面的规则将战胜先前的规则。这就是所谓的书写顺序。

例子：

```
p{
  color: red;
}
p{
  color:green;
}
```

上面的例子就是在权重相同的情况下，按照书写顺序去决定哪个规则取得胜利。第二个p的规则会胜出，从而显示的颜色为green。

以上就是比较规则，比较的顺序就是！important -> 权重 -> 书写顺序。

## 继承

在CSS中。元素的某个属性将由该元素的子元素继承。而有些不会。摆在我们面前的问题来了，到底那些会？那些不会？

1. 字体样式很多是被继承的
2. 作用在容器元素上的属性是不会被继承的。

字体的继承让我们在控制一个范围的字体，而不是每个元素都控制其字体的样式等属性。而容器上的属性不被继承是为了不让继承后的内部元素对布局产生影响。

当然，为了让我们更加精确的控制元素样式的继承。CSS提供了4个属性:inherit、initial、unset、revert。只是了解以上四个值的意义就可以了，我们并不深入的解释。

* inherit：将应用到选定元素的属性值设置为与其父元素一样；
* initial：设置为与浏览器默认样式表中该元素设置的值一样。
* unset：该值将属性重置为其自然值；
* revert： 如果当前的节点没有应用任何样式，则将该属性恢复到它所拥有的值；

## 总结

层叠是平时我们开发过程中最最常用的一个只是点。对我们在一个元素上挂载多个选择器的时候判定样式基准是及其重要的。这里是每个人必须清楚的，仅仅是了解是不够的。



