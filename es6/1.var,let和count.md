# var,let和count

#### 要点：**var**,**let**和**count**的使用方法和特性

var,let和count关键字的作用都是声明变量。区别在于三个关键字不同的特性和使用方法，这也是我们最需要了解他们的地方。

#### var

var关键字我们最熟悉不过，var给我们最大的困扰———**变量提升**，也就是说在函数作用域中，使用var关键字声明变量，无论我们声明位置在哪里，都会提升到当前作用域的最顶端。**变量提升**也恰恰是js中我们最容易忽略的坑。


```
function a(){
    console.log(b); //undefined
    var b = 1
};
```
上面的代码相当于：

```
function a(){
    var b
    console.log(b); //由于变量提升的缘故，声明b会提升到函数作用域顶端，此时b的值并为初始化，所用我们得到的是undefined
    var b = 1
};
```

var:var关键字需要注意的点就是**变量提升**，这是在面试中很常见的考察知识点。

#### let

let关键字只在所在的块级作用域有效，let关键字的特点是不会**变量提升**，而是锁在当前的块中。


```
function a(){
    if(true){
        console.log(a); //暂时性死区,用来描述变量不提升的现象
        let a = 1;
        var b = 2;
    }
    console.log(a); //a is not defined. let关键字只在块中有效，所以在if块之外访问a是无效的
    console.log(b); //2  
}
```

使用let的正确方法是：**先声明，在访问**

```
function a(){
    if(true){
        let a = 1;
        console.log(a); //1
    } 
}
```

let:let关键字我们需要注意的是let没有变量提升，作用域在块级上，而不是作用在函数作用域上。


#### count

count表示的是常量，一旦声明，无法被修改，而且必须进行初始化赋值，不可以留到以后赋值。


```
count a; //报错
```

count和let关键字的相同点是：只在声明所在的块级作用域内有效，而且也不**变量提升**，不能重复声明。
既然没有变量提升，也就和let一样有暂时性死区，所以也只能**先声明，在访问**



```
count a = 1;
a = 2; //报错。 因为count声明的变量无法重新赋值。
```

#### 总结

var，let和count如何选择呢？这需要看我们实际上变量是否需要更新，为了保证我们声明的变量不会恶意被修改，我们就会使用count关键字。声明对象的时候也推荐使用count关键字。而let关键字，只要可以使用var的情况下我们都可以使用let关键字进行替代。

还有就是var关键字的**变量提升**问题依旧值的我们注意和了解


